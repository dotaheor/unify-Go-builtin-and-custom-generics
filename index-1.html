<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Unknown </title></head><body>
<p>This contract proposal is a part of <a href="README.md">the generic design</a>.
It can also be used with other generic type and function declartion proposals.</p>
<p>This proposal suggests using some familar expressions used in daily Go programming
to constraint generic (type and const, etc) parameters.</p>
<h2 id="properties">Properties</h2>
<p><code>type</code> properties:
<em> <code>T.kind</code>, means the kind of the type represented by <code>T</code>.
</em> <code>T.value</code>, means an unspecified value of the type represented by <code>T</code>.
<em> <code>T.name</code>, means the name of the type represented by <code>T</code>. <code>""</code> for unnamed types.
</em> <code>T.signed</code>: whether or not the type represetned by <code>T</code> is a signed numeric type.
   (Not a very elementary property.
   There must be an aforementioned contract constrainting <code>T</code> to represent
   an integer or floating-point type to use this property.)
<em> <code>T.orderable</code>, whether or not the values of the type represetned by <code>T</code> can be compared with <code>&lt;</code> and <code>&gt;</code>, etc.
   (Not a very elementary property).
</em> <code>T.comparable</code>, whether or not the type represetned by <code>T</code> represents a comparable type.
<em> <code>T.embeddable</code>, whether or not ~~the type represetned by~~ <code>T</code> is embeddable.
</em> <code>T.base</code>: the base type of the pointer type represetned by <code>T</code>.
   (There must be an aforementioned contract constrainting <code>T</code> to represent
   a pointer type).
<em> <code>T.key</code>: the key type of the map type represetned by <code>T</code>.
   (There must be an aforementioned contract constrainting <code>T</code> to represent
   a map, slice, array or string type. If <code>T</code> is a slice, array or string type,
   then <code>T.key</code> is <code>int</code>).
</em> <code>T.element</code>: the element type of the type represetned by <code>T</code>.
   (There must be an aforementioned contract constrainting <code>T</code> to represent
   an array, slice, map, or channel type to use this property.)
<em> <code>T.length</code>: the length of the array type represetned by <code>T</code>.
   (There must be an aforementioned contract constrainting <code>T</code> to represent
   an array type).
</em> <code>T.receivable</code>: whether or not the type represetned by <code>T</code> represents a receivable channel type.
   (There must be an aforementioned contract constrainting <code>T</code> to represent
   a channel type).
<em> <code>T.sendable</code>: whether or not the type represetned by <code>T</code> represents a sendable channel type.
   (There must be an aforementioned contract constrainting <code>T</code> to represent
   a channel type).
</em> <code>T.methsets</code>: the method set of the type represetned by <code>T</code>.
<em> <code>T.fields</code>: the field set of the type represetned by <code>T</code>.
   (There must be an aforementioned contract constrainting <code>T</code> to represent
   a struct type).
</em> <code>T.selectors</code>: the selector set (both methods and fields) of the type represetned by <code>T</code>.
<em> <code>T.variadic</code>: whether or not the type represetned by <code>T</code> represents a variadic function type.
   (There must be an aforementioned contract constrainting <code>T</code> to represent
   a function type).
</em> <code>T.inputs.count</code>: the number of parameters of the function type represetned by <code>T</code>.
   (There must be an aforementioned contract constrainting <code>T</code> to represent
   a function type).
<em> <code>T.inputs.0</code>: the first parameter type of the function type represetned by <code>T</code>.
   (There must be an aforementioned contract constrainting <code>T</code> to represent
   a function type).
</em> <code>T.outputs.count</code>: the number of results of the function type represetned by <code>T</code>.
   (There must be an aforementioned contract constrainting <code>T</code> to represent
   a function type).
* <code>T.outputs.0</code>: the first result type of the function type represetned by <code>T</code>.
   (There must be an aforementioned contract constrainting <code>T</code> to represent
   a function type).</p>
<p><code>const</code> properties (the offical contract draft 2 doesn't support <code>const</code> generic parameters now,
but the proeperties are shown here anyway):
<em> <code>C.name</code>: the name of the constant represented by <code>C</code> is signed.
   The value might be <code>""</code> for intermediate values, such as <code>T.length.name</code>.
</em> <code>C.typed</code>: whether or not the constant represented by <code>C</code> is typed.
   (Maybe, it is good to require all generic constants must be typed.)
* <code>C.type</code>: the type or default type of a constant represented by <code>C</code>.</p>
<p><em>(<code>var</code>, <code>func</code>, <code>import</code> and <code>gen</code> can also be used as contract parameters/arguments,
but doing this will bring much complexity. So this is not supported temporarily.)</em></p>
<p>Note, the following properties were removed from this propsoal:
<em> <code>T.alias</code>: in fact, every generic parameter <code>T</code> is an alias,
   and the type represented by <code>T</code> is always not an alias,
   so this property is not essential.
</em> <code>T.underlying</code>: the property is too fundamental to be much useful and used directly.
<em> <code>T.defined</code>, same as the above one.
</em> <code>T.receiveonly</code>: makes the uses of generic arguments verbose.
* <code>T.sendonly</code>: same as the above one.</p>
<h2 id="the-assure-keyword">The <code>assure</code> keyword</h2>
<p>Each <code>assure</code> line describe a constraint, or a mini contract. (See following sections for examples).</p>
<p><em>(Other candidates to replace the <code>assure</code> keyword: <code>ensure</code>, <code>require</code>, <code>must</code>, <code>assert</code>, etc.)</em></p>
<p>Syntax
<code>assure expression</code></p>
<p>The proposed syntax is mainly to describe the following example purpose.
It can be another better form.</p>
<p>Not all expessions used the following examples are valid expressions used in daily Go programming. Please read the comments to get their meanings</p>
<h2 id="constrain-examples">Constrain examples</h2>
<p>Simple ones:
```
// T must represent a comparable type.
assure T.comparable</p>
<p>// Same as the above one.
assure T.value == T.value</p>
<p>// N and M must be two consts (either generic parameters not not).
assure N &gt; M</p>
<p>// T must represent an array type which length is not smaller than 8.
assure T.kind == [0]int.kind &amp;&amp; T.length &gt;= 8</p>
<p>// T1, T2 and T3 must represent the same type.
assure T1 == T2 == T3
```</p>
<p>More complex ones:
```
// Tx must represent a pointer type, Ty must represent a map type,
// and the values of the base type of Tx are assignable and comparable
// to values of the element type of Ty.
assure Tx.kind == (*int).kind
assure Ty.kind == (map[int]int).kind
assure Ty.element.value = Tx.base.value
assure Ty.element.value == Tx.base.value</p>
<p>// Ta must represent a slice type, Tb must represent a receiveable
// channel type, and values of the element type of Tb are convertiable
// to values of the element type of Ta.
assure Ta.kind == ([]int).kind &amp;&amp; Tb.kind == (chan int).kind
asusre Tb.receivable
assure Ta.element(Tb.element.value)
```</p>
<p>More:
```
// Specify the type represetned by T must have a specified method.
assure T.methods.M func(string) int</p>
<p>// Specify the struct type represetned by T must have a specified field.
assure T.fields.X int</p>
<p>// Specify the type represetned by T must have two specified selectors.
assure T.selectors.X int
assure T.selectors.F func(string) int // F can be either a method or a field of a function type</p>
<p>// Some more complex ones:
assure T.methods {
        .M1 func(string) int
        .M2 func(..int) (string, error)
        Ty.methods // embed a method set (a.k.a., T implements Ty)
    }
assure T.fields {
        .X int
        .Y string
        Tx.fields // embed a field set
    }
assure T.selectors {
        .X int
        .F func(string) int
        Tz.selectors // embed a selector set
    }
```</p>
<h2 id="intermediate-type-declarations-can-show-up-between-lines">Intermediate type declarations can show up between lines</h2>
<p>For convenience, some intermediate types are allowed to declared between assure lines.
For example:
<code>assure T.kind == (map[int]int).kind
type K, E = T.key, T.element
type I interface {
    M1() []K
    M2(E) bool
}
type S struct {
    Name string
    Keys []K
}
assure T.methods { I.methods }
assure T.fields { S.field }</code></p>
<h2 id="more-thinking">More thinking</h2>
<h3 id="allow-assure-lines-being-used-in-non-generic-code">Allow <code>assure</code> lines being used in non-generic code?</h3>
<p>Use <code>assure</code> lines as assert statements, but only limited to constant expressions, in non-geneirc code. Good?</p>
<h3 id="built-in-non-elementary-properties">Built-in non-elementary properties?</h3>
<p>In fact, the above listed properties <code>T.orderable</code> and <code>T.signed</code> are not very elementary.
There are more such non-elementary properties: <code>T.addable</code>, <code>T.subtractable</code>, <code>T.remaindable</code>,
<code>T.numeric</code>, <code>T.interger</code>, <code>T.floatingpoint</code>, <code>T.complex</code>, etc.</p>
<p>Good to add these ones? Or use the following introduced built-in contracts or kinds instead? </p>
<h3 id="built-in-contracts">Built-in contracts?</h3>
<p>Perhaps, it is good to predeclare some built-in named contracts to make some constraints
less verbose and more readable and standardized.</p>
<p>For example, <code>isNumeric[T]</code>, <code>isFloatingPoint[T]</code> and  <code>isInteger[T]</code> are more readable than
<code>T.numeric</code>, <code>T.floatingpoint</code> and <code>T.interger</code>, respectively.</p>
<p>More examples:
```
assure isArray[T] // isArray is a built-in contract
// is more readable and standardize than
assure T.kind == [0]int.kind</p>
<p>assure isInteger[T] &amp;&amp; t.signed // isInteger is a built-in contract
// is more readable and less verbose than
assure T.kind == int.kind || T.kind == int8.kind || T.kind == int16.kind || T.kind == int32.kind || T.kind == int64.kind</p>
<p>assure sameKind[T1, T2, T3, T4] // sameKind is a built-in contract
// is less verbose than
assure T1.kind == T2.kind == T3.kind == T4.kind</p>
<p>assure anyKind[T, T1, T2, T3] // anyKind is a built-in contract
// is less verbose (but also less readable?) than
assure T.kind == T1.kind || T.kind == T2.kind || T.kind == T3.kind</p>
<p>// (BTW, are the following two lines readable?)
assure T.kind == (T1 || T2 || T3).kind
assure sameKind[T, T1 || T2 || T3]
```</p>
<h3 id="built-in-kinds">Built-in kinds?</h3>
<p>The expression <code>T.kind == [0]int.kind</code> might be readable enough, but the <code>[0]int</code> in it
adds some irrelevant noises and might cuase some misleading.</p>
<p>Is it good to view <code>kind</code>s as integer values and predeclared all the kinds like
<code>const (
    Bool = 1 &lt;&lt; iota
    Int
    Uint
    ...
    Pointer
    Array
    Slice
    Map
    Channel
    Interface
    ...
    Integer =       Int || Uint || ... || Uintptr
    Signed =        Int || Int8 || Int16 || Int32 || Int64
    Unsgined =      Uint || Uint8 || Uint16 || Uint32 || Uint64 || Uintptr
    FloatingPoint = Float32 || Float64
    Complex =       Complex64 || Complex128
)</code>
?</p>
<p>Then the expression <code>T.kind == [0]int.kind</code> may be re-written as <code>T.kind == Array</code>,
which is more clean and readable.</p>
<p>More examples:
```
assure T.kind == int.kind || T.kind == int8.kind || T.kind == int16.kind || T.kind == int32.kind || T.kind == int64.kind
// may be re-written as
assure T.kind == Signed // The operation is not totally the same as that in general Go programming.
                        // It meas "T.kind &amp; Signed != 0" in general Go programming.</p>
<p>assure T.kind == T1.kind || T.kind == T2.kind || T.kind == T3.kind
// may be re-written as
assure T.kind == T1.kind | T.kind == T2.kind | T.kind == T3.kind
// which is not much different but a little more reasonable.
```</p>
<h2 id="tailored-for-the-contract-draft-v2">Tailored for the contract draft v2</h2>
<p>In the above examples, the contract syntax used is defined in <a href="README.md">this generic propsoal</a>.
For <a href="https://go.googlesource.com/proposal/+/master/design/go2draft-contracts.md">the offical contract draft 2</a>,
some modifications are needed:
<em> the <code>[]</code> which encloses generic arguments of built-in contracts should be replaced with <code>()</code>.
</em> the <code>assure</code> lines can be put in <code>contract</code> declartion bodies, but it would be better to
  replace the <code>assure</code> keyword with another better way which is more suitable for the draft.
  For example, an <code>assure expression</code> line can be written as <code>{ expression }</code>.</p>
</body></html>